;;;; filesys.test --- test file system functions -*- scheme -*-
;;;; 
;;;; Copyright (C) 2004, 2006, 2013, 2019, 2021 Free Software Foundation, Inc.
;;;; Copyright (C) 2021 Maxime Devos <maximedevos@telenet.be>
;;;; 
;;;; This library is free software; you can redistribute it and/or
;;;; modify it under the terms of the GNU Lesser General Public
;;;; License as published by the Free Software Foundation; either
;;;; version 3 of the License, or (at your option) any later version.
;;;; 
;;;; This library is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;;;; Lesser General Public License for more details.
;;;; 
;;;; You should have received a copy of the GNU Lesser General Public
;;;; License along with this library; if not, write to the Free Software
;;;; Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

(define-module (test-suite test-filesys)
  #:use-module (test-suite lib)
  #:use-module (test-suite guile-test)
  #:use-module (ice-9 threads)
  #:use-module (ice-9 match)
  #:use-module (rnrs io ports)
  #:use-module (rnrs bytevectors))

(define (test-file)
  (data-file-name "filesys-test.tmp"))
(define (test-symlink)
  (data-file-name "filesys-test-link.tmp"))


;;;
;;; copy-file
;;;

(with-test-prefix "copy-file"

  ;; return next prospective file descriptor number
  (define (next-fd)
    (let ((fd (dup 0)))
      (close fd)
      fd))

  ;; in guile 1.6.4 and earlier, copy-file didn't close the input fd when
  ;; the output could not be opened
  (pass-if "fd leak when dest unwritable"
    (let ((old-next (next-fd)))
      (false-if-exception (copy-file "/dev/null" "no/such/dir/foo"))
      (= old-next (next-fd)))))

;;;
;;; lstat
;;;

(with-test-prefix "lstat"

  (pass-if "normal file"
    (call-with-output-file (test-file)
      (lambda (port)
	(display "hello" port)))
    (eqv? 5 (stat:size (lstat (test-file)))))

  (call-with-output-file (test-file)
    (lambda (port)
      (display "hello" port)))
  (false-if-exception (delete-file (test-symlink)))
  (if (not (false-if-exception
	    (begin (symlink (test-file) (test-symlink)) #t)))
      (display "cannot create symlink, lstat test skipped\n")
      (pass-if "symlink"
	;; not much to test, except that it works
	(->bool (lstat (test-symlink))))))

;;;
;;; opendir and friends
;;;

(with-test-prefix "opendir"

  (with-test-prefix "root directory"
    (let ((d (opendir "/")))
      (pass-if "not empty"
	(string? (readdir d)))
      (pass-if "all entries are strings"
	(let more ()
	  (let ((f (readdir d)))
	    (cond ((string? f)
		   (more))
		  ((eof-object? f)
		   #t)
		  (else
		   #f)))))
      (closedir d))))

;;;
;;; stat
;;;

(with-test-prefix "stat"

  (with-test-prefix "filename"

    (pass-if "size"
      (call-with-output-file (test-file)
	(lambda (port)
	  (display "hello" port)))
      (eqv? 5 (stat:size (stat (test-file))))))

  (with-test-prefix "file descriptor"

    (pass-if "size"
      (call-with-output-file (test-file)
	(lambda (port)
	  (display "hello" port)))
      (let* ((fd (open-fdes (test-file) O_RDONLY))
	     (st (stat fd)))
	(close-fdes fd)
	(eqv? 5 (stat:size st)))))

  (with-test-prefix "port"

    (pass-if "size"
      (call-with-output-file (test-file)
	(lambda (port)
	  (display "hello" port)))
      (let* ((port (open-file (test-file) "r+"))
	     (st   (stat port)))
	(close-port port)
	(eqv? 5 (stat:size st))))))

(with-test-prefix "sendfile"

  (let* ((file (search-path %load-path "ice-9/boot-9.scm"))
         (len  (stat:size (stat file)))
         (ref  (call-with-input-file file get-bytevector-all)))

    (pass-if-equal "file" (cons len ref)
      (let* ((result (call-with-input-file file
                       (lambda (input)
                         (call-with-output-file (test-file)
                           (lambda (output)
                             (sendfile output input len 0))))))
             (out (call-with-input-file (test-file) get-bytevector-all)))
        (cons result out)))

    (pass-if-equal "file with offset"
        (cons (- len 777) (call-with-input-file file
                            (lambda (input)
                              (seek input 777 SEEK_SET)
                              (get-bytevector-all input))))
      (let* ((result (call-with-input-file file
                       (lambda (input)
                         (call-with-output-file (test-file)
                           (lambda (output)
                             (sendfile output input (- len 777) 777))))))
             (out (call-with-input-file (test-file) get-bytevector-all)))
        (cons result out)))

    (pass-if-equal "file with offset past the end"
        (cons (- len 777) (call-with-input-file file
                            (lambda (input)
                              (seek input 777 SEEK_SET)
                              (get-bytevector-all input))))
      (let* ((result (call-with-input-file file
                       (lambda (input)
                         (call-with-output-file (test-file)
                           (lambda (output)
                             (sendfile output input len 777))))))
             (out (call-with-input-file (test-file) get-bytevector-all)))
        (cons result out)))

    (pass-if-equal "file with offset near the end"
        (cons 77 (call-with-input-file file
                   (lambda (input)
                     (seek input (- len 77) SEEK_SET)
                     (get-bytevector-all input))))
      (let* ((result (call-with-input-file file
                       (lambda (input)
                         (call-with-output-file (test-file)
                           (lambda (output)
                             (sendfile output input len (- len 77)))))))
             (out (call-with-input-file (test-file) get-bytevector-all)))
        (cons result out)))

    (pass-if-equal "pipe" (cons len ref)
      (if (provided? 'threads)
          (let* ((in+out (pipe))
                 (child  (call-with-new-thread
                          (lambda ()
                            (call-with-input-file file
                              (lambda (input)
                                (let ((result (sendfile (cdr in+out)
                                                        (fileno input)
                                                        len 0)))
                                  (close-port (cdr in+out))
                                  result)))))))
            (let ((out (get-bytevector-all (car in+out))))
              (close-port (car in+out))
              (cons (join-thread child) out)))
          (throw 'unresolved)))

    (pass-if-equal "pipe with offset"
        (cons (- len 777) (call-with-input-file file
                            (lambda (input)
                              (seek input 777 SEEK_SET)
                              (get-bytevector-all input))))
      (if (provided? 'threads)
          (let* ((in+out (pipe))
                 (child  (call-with-new-thread
                          (lambda ()
                            (call-with-input-file file
                              (lambda (input)
                                (let ((result (sendfile (cdr in+out)
                                                        (fileno input)
                                                        (- len 777)
                                                        777)))
                                  (close-port (cdr in+out))
                                  result)))))))
            (let ((out (get-bytevector-all (car in+out))))
              (close-port (car in+out))
              (cons (join-thread child) out)))
          (throw 'unresolved)))))

(with-test-prefix "basename"

  (pass-if-equal "/" "/" (basename "/"))
  (pass-if-equal "//" "/" (basename "//"))
  (pass-if-equal "a/b/c" "c" (basename "a/b/c")))

(delete-file (test-file))
(when (file-exists? (test-symlink))
  (delete-file (test-symlink)))


(with-test-prefix "mkdtemp"

  (pass-if-exception "number arg" exception:wrong-type-arg
    (if (not (defined? 'mkdtemp))
        (throw 'unresolved)
        (mkdtemp 123)))

  (pass-if "template prefix is preserved"
    (if (not (defined? 'mkdtemp))
        (throw 'unresolved)
        (let* ((template "T-XXXXXX")
               (name (mkdtemp template)))
          (false-if-exception (rmdir name))
          (and
           (string? name)
           (string-contains name "T-")
           (= (string-length name) 8)))))

  (pass-if-exception "invalid template" exception:system-error
    (if (not (defined? 'mkdtemp))
        (throw 'unresolved)
        (mkdtemp "T-AAAAAA")))

  (pass-if "directory created"
    (if (not (defined? 'mkdtemp))
        (throw 'unresolved)
        (let* ((template "T-XXXXXX")
               (name (mkdtemp template)))
          (let* ((_stat    (stat name))
                 (result   (eqv? 'directory (stat:type _stat))))
            (false-if-exception (rmdir name))
            result)))))

(with-test-prefix "chdir"
  (pass-if-equal "current directory" (getcwd)
    (begin (chdir ".") (getcwd)))
  (define file (search-path %load-path "ice-9/boot-9.scm"))


  (pass-if-equal "test directory" (dirname file)
    (let ((olddir (getcwd))
          (dir #f))
      (chdir (dirname file))
      (set! dir (getcwd))
      (chdir olddir)
      dir))

  (pass-if-equal "test directory, via port" (dirname file)
    (unless (provided? 'chdir-port)
      (throw 'unresolved))
    (let ((olddir (getcwd))
          (port (open (dirname file) O_RDONLY))
          (dir #f))
      (chdir port)
      (set! dir (getcwd))
      (chdir olddir)
      dir))

  (pass-if-exception "closed port"  exception:wrong-type-arg
    (unless (provided? 'chdir-port)
      (throw 'unresolved))
    (let ((port (open (dirname file) O_RDONLY))
          (olddir (getcwd)))
      (close-port port)
      (chdir port)
      (chdir olddir))) ; should not be reached

  (pass-if-exception "not a port or file name" exception:wrong-type-arg
    (chdir '(stuff)))

  (pass-if-exception "non-file port" exception:wrong-type-arg
    (chdir (open-input-string ""))))

(with-test-prefix "readlink"
  (false-if-exception (delete-file (test-symlink)))
  (false-if-exception (delete-file (test-file)))
  (call-with-output-file (test-file)
    (lambda (port)
      (display "hello" port)))
  (if (not (false-if-exception
	    (begin (symlink (test-file) (test-symlink)) #t)))
      (display "cannot create symlink, some readlink tests skipped\n")
      (let ()
        (pass-if-equal "file name of symlink" (test-file)
          (readlink (test-symlink)))

        (pass-if-equal "port representing a symlink" (test-file)
          (let ()
            (unless (and (provided? 'readlink-port)
                         (defined? 'O_NOFOLLOW)
                         (defined? 'O_PATH)
                         (not (= 0 O_NOFOLLOW))
                         (not (= 0 O_PATH)))
              (throw 'unsupported))
            (define port (open (test-symlink) (logior O_NOFOLLOW O_PATH)))
            (define points-to (false-if-exception (readlink port)))
            (close-port port)
            points-to))

        (pass-if-exception "not a port or file name" exception:wrong-type-arg
          (readlink '(stuff)))))

  (pass-if-equal "port representing a regular file" EINVAL
    (call-with-input-file (test-file)
      (lambda (port)
        (unless (provided? 'readlink-port)
          (throw 'unsupported))
        (catch 'system-error
          (lambda ()
            (readlink port)
            (close-port port) ; should be unreachable
            #f)
          (lambda args
            (close-port port)
            ;; At least Linux 5.10.46 returns ENOENT instead of EINVAL.
            ;; Possibly surprising, but it is documented in some man
            ;; pages and it doesn't appear to be an accident:
            ;; <https://elixir.bootlin.com/linux/v5.10.46/source/fs/stat.c#L419>.
            (define error (system-error-errno args))
            (if (= error ENOENT)
                EINVAL
                error))))))

  (pass-if-exception "non-file port" exception:wrong-type-arg
    (readlink (open-input-string "")))

  (pass-if-exception "closed port" exception:wrong-type-arg
    (let ((port (open-file (test-file) "r")))
      (close-port port)
      (readlink port)))

  (false-if-exception (delete-file (test-symlink)))
  (false-if-exception (delete-file (test-file))))
